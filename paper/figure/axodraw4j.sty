\ProvidesPackage{axodraw4j}[2008/11/19]
\typeout{Document option: axodraw4j. 19 Nov 2008}

\typeout{***************************************************************************}
\typeout{WARNING: use of axodraw4j is recommended only in conjunction with JaxoDraw!}
\typeout{.....See http://jaxodraw.sourceforge.net/ for information on JaxoDraw......}
\typeout{***************************************************************************}

%   Style file for the drawing of Feynman diagrams with LaTeX.
%   It assumes that the dvips that is used is by Radical Eye Software
%   (by Rokicki), because the graphics primitives are given in
%   postscript. If you do not work with a dvi to postscript converter
%   you are out of luck.
%
%   Original version made by J.A.M. Vermaseren 14-feb-1994
%   Current version maintained by John Collins
%             collins at phys dot psu dot edu
%   with code by Daniele Binosi and Lukas Theussl.
% Copyright J.A.M. Vermaseren, John Collins, Daniele Binosi and Lukas
% Theussl (1994-2008).
%% This package may be distributed under the terms of the LaTeX Project Public
%% License, as described in lppl.txt in the base LaTeX distribution.
%% Either version 1.0 or, at your option, any later version.


%   Use:
%   Enter the picture environment with for instance
%   \begin{picture}(width,height)(0,0)
%       statements
%   \end{picture}
%   All statements should be entered inside the picture environment.
%   All coordinates should be in terms of pt (but the pt must be omitted).
%   One may also use the figure environment.


% Issues:
%         1.  a. Global scaling: axoscale applies to graphics, but not to
%                text
%             b. Text uses \unitlength, but graphics does not
%             c. Drawing of postscript works in (postscript) points,
%                but picture works in terms of \unitlength, which by
%                default coincide.
%             d. Note that \SetScale{4}\setlength{\unitlength}{4pt}
%                appears to work appropriately: graphics and positions
%                are scaled, but text size is unscaled.
%             e. User could legitimately set \unitlength, since that
%                is documented for the picture environment.  But AXO
%                drawings should be insulated from that, or they
%                should consistently use \unitlength 
%             f. Perhaps there should be an axopicture environment,
%                which is picture environment which sets \unitlength 
%                to 1pt?  Done
%        2.   Need \GluonBezier and \PhotonBezier.  Could use code in
%                JD for the drawing routines.  See JaxoGlBezier.java, 
%                and JaxoPBezier.java.  Not urgent, since JD does 
%                implement them in some way.



\RequirePackage{keyval}

% Ideas from usenet message on comp.text.tex, Alberto L  29 Oct 2004.
\IfFileExists{colordvi.sty}{
    \RequirePackage{colordvi}   % For colorname macros like \Black
                                % This is used by jaxodraw when it invokes
                                % axodraw
    \background{White}
    \textBlack
    \def\axocolor{Black }
    \def\SetColor##1{\def\axocolor{##1 }}
    \def\IfColor##1##2{##1}
}{
    % Fixups in case of absence of colordvi.sty
    \def\axocolor{ }
    \def\SetColor##1{\def\axocolor{ }}
    \def\Color##1##2{##2}
    \def\IfColor##1##2{##2}
}

\input{rotate}

%=========================================================

%  Commands to set parameters
%
%  Arrow scale:
\newcommand{\AXO@DefaultArrowScale}{1}
\newcommand\SetArrowScale[1]{%
    \renewcommand\AXO@DefaultArrowScale{#1}%
}
% Alternative name
\newcommand\DefaultArrowScale[1]{\SetArrowScale{#1}}
\SetArrowScale{1}

% Arrow inset:
\newcommand\AXO@ArrowInset{0.2}
%\renewcommand\AXO@ArrowInset{-1 }
\newcommand\SetArrowInset[1]{%
    \renewcommand\AXO@ArrowInset{#1}%
}

% Arrow aspect:
\newcommand\AXO@DefaultArrowAspect{1.25}
\newcommand\SetArrowAspect[1]{%
    \renewcommand\AXO@DefaultArrowAspect{#1}%
}

% Arrow position (fractional position along line):
\newcommand\AXO@ArrowPos{0.5}
\newcommand\SetArrowPosition[1]{%
    \renewcommand\AXO@ArrowPos{#1}%
}

% Arrow stroke width
\newcommand{\AXO@DefaultArrowStroke}{1}
\newcommand\SetArrowStroke[1]{%
    \renewcommand\AXO@DefaultArrowStroke{#1}%
}


%=========================================================

%=========================================================
%=========================================================
%=================  PostScript preamble
\AtBeginDvi{
%    This forces the PostScript preamble commands to be put into the
%       dvi file.  Without this, revtex4 can remove them by funny
%       stuff with manipulating the first page.
%
%               #[ inventory :
%
%   The variables in here are:
%   num,num1,ampi,ampi1,x1,y1,x2,y2,x3,y3,x4,y4,dx,dy,dr
%   width, arrowpos, arrowspec, arrowwidth, arrowlength, arrowinset
%   arcend, arcmid, arcstart, radius, linesep, angdsize, dsize,
%   clockwise, dotsize, inc, pi, sign
%   darc,const,amp1, amp2, amp3, amp4, amp5, amp6, amp7, amp8, amp1i
%   gcolor,xx2
%
%   NOTE: blank lines are not allowed inside the postscript code!!!!!
%   (LaTeX sneaks \par commands in and the postscript goes boink)
%
\special{color}  % Provoke dvips into including color.pro
                 % Revtex4 in 2-column mode fails to force that
\special{! 
    /pi 3.141592 def
    /ed{exch def}def 
    /gs{gsave dup scale}def
    /gsw{ gs
          /width ed
          width setlinewidth
    }def
    /p1{/y1 ed /x1 ed}def
    /p2{/y2 ed /x2 ed}def
    /p3{/y3 ed /x3 ed}def
    /p4{/y4 ed /x4 ed}def
    /garrow{/arrowpos ed /arrowspec ed}def
    /setabs{
        % Usage /var setabs
        % Sets variable to its absolute value
        dup load abs def
    }def
    %
    /normalizearc {
        % Usage: clockwise r angle1 angle2 x y normalizearc
        % Adjusts coordinate system for anticlockwize arc from angle
        % zero, centered at origin.
        % Left on stack: r d_angle, with 0<d_angle <=360.
        % Zero angle arc converted to loop
        translate
        exch dup rotate  % Origin of arc now at angle 0
        sub              % Change angle2 to dangle
        3 2 roll
        { % Clockwise arc: obtain from anticlockwise arc
          neg
          1 -1 scale
        } if
        dup abs 360 ge 
        {  %Outside 360 degrees, make exactly a loop
           pop 360 
        }
        { % Convert to positive angle mod 360.  
           dup
           dup 0 lt { 360 sub } if
           360 div truncate 360 mul sub
           dup 0.1 lt { pop 360 } if
        }ifelse
    } def
    %
    /normalizeline {
        % Usage: x1 y1 x2 y2 normalizeline
        % Adjusts coordinate system for line from origin in x direction
        % Left on stack: dr = length of line
        3 index 3 index translate
        2 index sub exch 3 index sub
        2 copy atan rotate
        dup mul exch dup mul add sqrt
        3 1 roll pop pop
    } def
    %
    /abox{
        newpath 
            x1 y1 moveto
            x1 y2 lineto
            x2 y2 lineto
            x2 y1 lineto
         closepath
    }def
    /atriangle{
        newpath
            x1 y1 moveto
            x2 y2 lineto
            x3 y3 lineto
        closepath
   }def
   /abezier{
       newpath
           x1 y1 moveto
           x2 y2 x3 y3 x4 y4 curveto
   }def
   /distance{
      %   Usage: x1 y1 x2 y2 distance -> x1 y1 x2 y2 r
      %   Pure stack based: computes distance between points.  Keeps points
     dup
     3 index sub dup mul 
     2 index 5 index sub dup mul add sqrt
   } def
}
%
%               #] inventory : 
%
%============================================================
%============================================================
%
% Define better arrows
%
\special{!
% Arrow making routines
%
%   Arrow drawing:
%
    /arrowVTriangle {
        % Down-pointing arrow: arrowstroke width length inset arrowVTriangle
        /arrowinset  ed
        /arrowlength ed
        /arrowwidth  ed
        /arrowstroke ed
        newpath
            0           arrowlength -0.5 mul moveto         
            arrowwidth  arrowlength          rlineto
            arrowwidth -1  mul  arrowlength arrowinset mul -1 mul rlineto
            arrowwidth -1  mul  arrowlength arrowinset mul rlineto
        closepath 
        arrowstroke 0 ne {
           gsave 
              arrowstroke setlinewidth stroke 
           grestore
        } if
        fill 
    } def
%
%  General arrow.  Call as { arrowspec } angle arrow
%       arrow is drawn at angle degrees clockwise of down
%       arrowspec is code for drawing a downward pointing arrow
   /arrow1 {
       gsave
           rotate
           exec
       grestore
   } def
%
}
%
%============================================================
%============================================================
% Basic line drawing
%               #[ fixdash :
%
\special{! /fixdash{
%   Usage: r dashsize fixdash
%   Sets renormalized dashsize, doing
%      [rdsize rdsize] 0 setdash
%   so that n+1/2 patterns fit in length r
%   If dsize is too big or if dsize is zero, use continuous line
%   Uses stack, no named variables.
    2 copy gt 
    1 index 0 ne 
    and 
    {
       2 copy 
       2 mul div 0.5 sub round 
       dup 0 le { pop 0 } if
       2 mul 1 add exch pop div
       dup 2 array astore 0 setdash
    } 
    { pop pop [] 0 setdash }
    ifelse
} def }
%
%               #] fixdash : 
%               #[ dashline :
%
\special{! /dashline{
%   Draws a straight dashed line: x1,y1,x2,y2
%   Assumes dsize already set
%   The pattern is ideally [dsize dsize] 0 setdash
%   but we want to have (2*n+1)/2 patterns, so dsize must be rounded
%   If dsize is too large or zero, use a continuous line
%   Pure stack operation. 
    gsave
    distance dsize fixdash   % Function distance leaves points on stack
    newpath
      moveto
      lineto
    stroke
    grestore
} def }
%               #] dashline : 
%               #[ dasharc :
%
\special{! /dasharc{
%   Draws an arc segment anticlockwise:
%   x_center, y_center, radius, start_angle, end_angle
%   Assumes angdsize (radians) set elsewhere
    gsave
    3 copy sub abs
    % Top of stack is copy of radius, start_angle, end_angle
    pi mul 180 div mul 
    % Top of stack is arc length
    3 index angdsize mul fixdash
    newpath  arc stroke
    grestore
} def }
%
%               #] dasharc : 
%============================================================
%============================================================
%
%               #[ doublegluon :
%
\special{! /doublegluon{
%
%   Draw gluon, possibly double
%   We have a 'head' and a 'tail' and inbetween the 'body'
%   The head + tail is 2 windings. The body is num-1 windings.
%
    gsw 
    /linesep ed
    /num ed /ampi ed 
    normalizeline /dr ed
%
    linesep 0 eq 
       { 0 0 dr 0 ampi num gluon1 }
       {
         0 linesep 2 div  dup dr exch  ampi num gluon1 
         0 linesep -2 div dup dr exch  ampi num gluon1 
       }
    ifelse
    grestore
} def }
%
%               #] doublegluon : 
%               #[ gluon1 :
%
\special{! /gluon1{
% Draw a single gluon
%   We have a 'head' and a 'tail' and inbetween the 'body'
%   The head + tail is 2 windings. The body is num-1 windings.
%
    gsave
    /num ed /ampi ed 
    normalizeline /dr ed
%
    /num num 0.5 sub round def
    /inc dr num 2 mul 2 add div def         % increment per half winding
    /amp8 ampi 0.9 mul def
    amp8 0 lt {/amp8 amp8 neg def} if
%
    /x1 inc 2 mul def
%
    newpath
        0 0 moveto
        inc 0.1 mul ampi 0.5 mul inc 0.5 mul ampi inc 1.4 mul ampi curveto
        x1 amp8 add dup ampi exch ampi neg dup x1 exch curveto
%
        2 1 num {
            pop
            x1 amp8 sub dup ampi neg exch ampi dup x1 inc add exch curveto
            /x1 x1 inc dup add add def
            x1 amp8 add dup ampi exch ampi neg dup x1 exch curveto
        } for
%
        x1 amp8 sub dup ampi neg exch ampi dup x1 inc 0.6 mul add exch curveto
        x1 inc 1.5 mul add ampi dr inc 0.1 mul sub ampi 0.5 mul dr 0 curveto
    stroke
%
    grestore
} def }
%
%               #] gluon1 : 
%               #[ doublephoton :
%
\special{! /doublephoton{
%
%   Draws a photon from x1,y1 to x2,y2 with amplitude A and n wiggles
%   Possibly double
%
    gsw 
    /linesep ed
    /num ed /ampi ed 
    normalizeline /dr ed
%
    linesep 0 eq 
       { 0 0 dr 0 ampi num photon1 }
       {
         0 linesep 2 div  dup dr exch  ampi num photon1 
         0 linesep -2 div dup dr exch  ampi num photon1 
       }
    ifelse
    grestore
} def }
%
%               #] doublephoton : 
%               #[ photon1 :
%
\special{! /photon1{
%
%   Draws a single photon from x1,y1 to x2,y2 with amplitude A and n wiggles
%
    gsave
    /num1 ed /ampi1 ed 
    normalizeline /dr ed
%
    /num1 num1 2 mul 0.5 sub round def
    /x2 dr num1 div def
    /sign 1 def
    1 1 num1 {
        pop
        newpath
        0 0 moveto
        4 3 div x2 mul pi div dup neg x2 add
        4 3 div ampi1 sign mul mul dup 3 1 roll
        x2 0 curveto
        stroke
        /sign sign neg def
        x2 0 translate
    } for
%
    grestore
} def }
%
%               #] photon1 : 
%               #[ zigzag :
%
\special{! /zigzag{
%
%   Draws a zigzag line from x1,y1 to x2,y2 with amplitude A and n zigzags
%
    gsw /num ed /ampi ed 
    normalizeline /dr ed
%
    /num num 2 mul 0.5 sub round def
    /x2 dr num div def
    /sign 1 def
    1 1 num {
        pop
        newpath
        0 0 moveto
        x2 2 div ampi sign mul lineto
        x2 0 lineto
        stroke
        /sign sign neg def
        x2 0 translate
    } for
%
    grestore
} def }
%
%               #] zigzag : 
%               #[ doublephotonarc :
%
\special{! /doublephotonarc{
%
%   Draws a gluon on an arcsegment
%   gluon_radius, num, linesep (0 for no-double),
%   clock, radius, start_angle, end_angle, x_center, y_center
%   in which num is the number of wiggles of the photon.
%
    gsw 
    normalizearc
    /darc ed  /radius ed  /linesep ed /num ed /ampli ed
%
    /num num 2 mul round def    % number of half wiggles
    /darc1 darc num div def
    /cp darc1 cos def
    /sp darc1 sin def
    darc1 2 div dup
    /cp2 exch cos def
    /sp2 exch sin def
%
    linesep 0 eq 
       { 
          radius photonarc1 
       }
       {
         linesep 2 div  radius add photonarc1 
         linesep -2 div radius add photonarc1 
       }
    ifelse
%
    grestore
} def }
%
%               #] doublephotonarc : 
%               #[ photonarc1 :
%
\special{! /photonarc1{
%   Usage: radius photonarc1
%   Draws a single photon on an arcsegment.
%   Called from doublephotonarc with coordinates centered on center,
%   start on x-axis.  
%   Assume the following are set: num, ampli, arcend phi, arcstart phi/2, cp,
%      cp2, sp, sp2.
%   Draws a photonarc center at x1,y1, radius arcstart,arcend, amplitude
%       number of wiggles,  width, scale
%
    gsave
    /radius1 ed
    % Local copy of amplitude, since I change it
    /ampli1 ampli def
%
    newpath
    1 1 num {
        pop
        radius1 0 moveto
        /beta radius1 darc1 mul 180 ampli1 mul div def
        /tt sp cp beta mul sub cp sp beta mul add div def
        /amp1 radius1 ampli1 add 8 mul beta cp2 mul sp2 sub mul beta 4 cp add mul
            tt cp mul 3 mul sp 4 mul sub add radius1 mul sub
            beta tt sub 3 mul div def           % this is x2
        radius1 ampli1 add 8 mul cp2 mul 1 cp add radius1 mul sub 3 div amp1 sub
            dup radius1 sub beta mul             % x1,y1
        amp1 dup radius1 cp mul sub tt mul radius1 sp mul add     % x2,y2
        radius1 cp mul radius1 sp mul             % x3 y3
                curveto
        /ampli1 ampli1 neg def
        darc1 rotate
    } for
    stroke
%
    grestore
} def }
%
%               #] photonarc : 
%               #[ doublegluearc :
%
\special{! /doublegluearc{
%
%   Draws a gluon on an arcsegment
%   gluon_radius, num, linesep (0 for no-double), 
%   clock, radius, start_angle, end_angle, x_center, y_center
%   in which num is the number of windings of the gluon.
%
    gsw 
    normalizearc
    /darc ed  /radius ed  /linesep ed /num ed /ampi ed
    /num num 0.5 sub round def
%
    linesep 0 eq 
       { radius gluearc1 }
       {
         linesep 2 div  radius add gluearc1 
         linesep -2 div radius add gluearc1 
       }
    ifelse
%
    grestore
} def }
%
%               #] doublegluearc :
%               #[ gluearc1 :
\special{! /gluearc1{
%   Usage: radius gluearc1
%   Draws a single gluon on an arcsegment.
%   Called from doublegluearc with coordinates centered on center,
%   start on x-axis.  
%   Assume: num, ampi and darc set.
%   Method:
%   1:  compute length of arc.
%   2:  generate gluon in x and y as if the arc is a straight line
%   3:  x' = (radius+y)*cos(x*const)
%       y' = (radius+y)*sin(x*const)
%
    gsave
    /radius1 ed
    /dr radius1 darc mul pi mul 180 div def  % length of segment.
    /const darc dr div def                  % conversion constant
    darc 360 lt 
    {
          /inc dr num 2 mul 2 add div def    % increment per half winding
    }
    {     % Full loop, so don't have extra bits on end
          /inc dr num 2 mul div def    % increment per half winding
    }
    ifelse
%
    /amp8 ampi 0.9 mul def
    /amp1 radius1 ampi add def
    /amp2 radius1 ampi sub def
    /amp3 radius1 ampi 2 div add def
    /amp4 amp1 inc amp8 add const mul cos div def
    /amp5 amp2 amp8 const mul cos div def
    /amp6 amp1 inc 0.6 mul amp8 add const mul cos div def
    /amp7 amp1 inc 0.9 mul const mul cos div def
    amp8 0 lt {/amp8 amp8 neg def} if
%
%
    newpath
        darc 360 lt 
        {
            /x1 inc 2 mul def
            radius1 0 moveto
            % Normal arc has special head segment
            inc 0.1 mul const mul dup cos amp3 mul exch sin amp3 mul
            inc 0.5 mul const mul dup cos amp7 mul exch sin amp7 mul
            inc 1.4 mul const mul dup cos amp1 mul exch sin amp1 mul
                curveto
            x1 amp8 add const mul dup cos amp6 mul exch sin amp6 mul
            x1 amp8 add const mul dup cos amp5 mul exch sin amp5 mul
            x1 const mul dup cos amp2 mul exch sin amp2 mul
                curveto
            % Range of main segments
            2 1 num 
        }
        { 
            /x1 0 def
            amp2 0 moveto
            1 1 num
        }
        ifelse
        {
            pop
            x1 amp8 sub const mul dup cos amp5 mul exch sin amp5 mul
            x1 amp8 sub const mul dup cos amp4 mul exch sin amp4 mul
            x1 inc add const mul dup cos amp1 mul exch sin amp1 mul
                curveto
            /x1 x1 inc dup add add def
            x1 amp8 add const mul dup cos amp4 mul exch sin amp4 mul
            x1 amp8 add const mul dup cos amp5 mul exch sin amp5 mul
            x1 const mul dup cos amp2 mul exch sin amp2 mul
                curveto
        } for
%
        darc 360 lt 
        {
            x1 amp8 sub const mul dup cos amp5 mul exch sin amp5 mul
            x1 amp8 sub const mul dup cos amp6 mul exch sin amp6 mul
            x1 inc 0.6 mul add const mul dup cos amp1 mul exch sin amp1 mul
                curveto
            x1 inc 1.5 mul add const mul dup cos amp7 mul exch sin amp7 mul
            dr inc 0.1 mul sub const mul dup cos amp3 mul exch sin amp3 mul
            dr const mul dup cos radius1 mul exch sin radius1 mul
                curveto
        }
        if
    stroke
%
    grestore
} def }
%
%               #] gluearc1 :
%               #[ dasharrowdoubleline :
%
\special{! /dasharrowdoubleline{
%
%   arrowspec, arrowpos, flip, linesep, dsize,
%       x1, y1, x2, y2, width, scale
%   If linesep == 0, then single line, else double with separation linesep. 
%   Draws a dashed double straight line with arrow. 
%   If dsize==0, then continuous line.
%   If linesep==0, then single line.
    gsw 
    normalizeline
    /dr ed
    /dsize ed 
    /linesep ed
    /flip ed
    garrow
%
    % If linesep is negative, that means the arrow is flipped.
    % But the lineend coordinates are already flipped, so there is
    % no need to make any adjustment; i.e., replace linesep by
    % absolute value.
    /linesep setabs
    /linewidth width def
%
    /y11 linesep 0.5 mul def
    /y22 linesep -0.5 mul def
    0 y11 dr arrowpos mul y11 dashline
    linesep 0 ne 
       { 0 y22 dr arrowpos mul y22 dashline }
    if
    dr arrowpos mul 0 translate
    /arrowspec load 
    flip { -90 }{ 90 } ifelse
    arrow1
    0 y11 dr 1 arrowpos sub mul y11 dashline
    linesep 0 ne 
       { 0 y22 dr 1 arrowpos sub mul y22 dashline }
    if
    grestore
} def }
%
%               #] dasharrowdoubleline : 
%               #[ arc2 :
%
\special{! /arc2{
%   Draws an arc segment:
%   arrowspec, arrowpos, flip, linesep, dsize,
%       clock, radius, start_angle, end_angle, x_center, y_center, width, scale
%   If linesep == 0, then single line, else double with separation linesep. 
%
    gsw
    normalizearc
    /darc ed /radius ed
    /dsize ed /linesep ed 
    /angdsize dsize radius div def
    /flip ed
    garrow
    /arcmid
       darc arrowpos mul
    def
    dsize 0 eq 
    { linesep 0 eq 
         { 0 0 radius 0 darc dasharc }
         { 0 0 radius linesep 2 div add 0 darc dasharc
           0 0 radius linesep -2 div add 0 darc dasharc
         }
      ifelse
    }
    { linesep 0 eq 
         { 0 0 radius 0 arcmid dasharc 
           0 0 radius arcmid darc dasharc
         }
         { 
           0 0 radius linesep 2 div add 0 arcmid dasharc
           0 0 radius linesep -2 div add 0 arcmid dasharc
           0 0 radius linesep 2 div add arcmid darc dasharc
           0 0 radius linesep -2 div add arcmid darc dasharc
         }
      ifelse
    }
    ifelse
    arcmid rotate 
    radius 0 translate 
    /arrowspec load  flip { 0 } { 180 } ifelse arrow1
    grestore
} def }
%
%               #] arc2 : 
%               #[ vertex :
%
\special{! /vertex{
%
%   Puts a fat dot at x,y  size is the radius of the dot
%
    gs
    /dotsize ed
    translate
    newpath
        0 0 dotsize 0 360 arc
    fill stroke
    grestore
} def }
%
%               #] vertex : 
%               #[ bcirc :
%
\special{! /bcirc{
%
%   Draws an anti-clockwise blanked circle:
%   x_center, y_center, radius
%
    gsw /radius ed
%
    translate                               % x and y are still on stack
%
    gsave
    1 setgray
    newpath 0 0 radius 0 360 arc fill
    grestore
    newpath 0 0 radius 0 360 arc stroke
    grestore
} def }
%
%               #] bcirc : 
%               #[ gcirc :
%
\special{! /gcirc{
%
%   Draws an anti-clockwise blanked gray circle:
%   x_center, y_center, radius, grayscale
%
    gsw /gcolor ed /radius ed
%
    translate                               % x and y are still on stack
%
    1 setgray
    newpath 0 0 radius 0 360 arc fill
    gcolor setgray
    newpath 0 0 radius 0 360 arc fill
    0 setgray
    newpath 0 0 radius 0 360 arc stroke
    grestore
} def }
%
%               #] gcirc : 
%               #[ ccirc1 :
%
\special{! /ccirc1{
%
%   Draws an anti-clockwise circle :
%   x_center, y_center, radius
%   Part 1: the contents in background color
%
    gsw /radius ed
%
    translate                               % x and y are still on stack
%
    newpath 0 0 radius 0 360 arc fill
    grestore
} def }
%
%               #] ccirc1 : 
%               #[ ccirc2 :
%
\special{! /ccirc2{
%
%   Draws an anti-clockwise circle :
%   x_center, y_center, radius
%   Part 1: the contents in background color
%
    gsw /radius ed
%
    translate                               % x and y are still on stack
%
    newpath 0 0 radius 0 360 arc stroke
    grestore
} def }
%
%               #] ccirc2 : 
%               #[ box :
%
\special{! /box{
%
%   Draws a box x1,y1,x2,y2
%
    gsw p2 p1
    abox stroke
    grestore
} def }
%
%               #] box : 
%               #[ bbox :
%
\special{! /bbox{
%
%   Draws a blanked out box x1,y1,x2,y2
%
    gsw p2 p1
    gsave
    1 setgray abox fill
    grestore
    abox stroke
    grestore
} def }
%
%               #] bbox : 
%               #[ gbox :
%
\special{! /gbox{
%
%   Draws a blanked out gray box x1,y1,x2,y2,color
%
    gsw /gcolor ed p2 p1
    1 setgray      abox fill
    gcolor setgray abox fill
    0 setgray      abox stroke
    grestore
} def }
%
%               #] gbox : 
%               #[ cbox1 :
%
\special{! /cbox1{
%
%   Draws a blanked out colored box x1,y1,x2,y2
%   Part 1: the background
%
    gsw p2 p1
    abox fill
    grestore
} def }
%
%               #] cbox1 : 
%               #[ cbox2 :
%
\special{! /cbox2{
%
%   Draws a blanked out colored box x1,y1,x2,y2
%   Part 1: the box
%
    gsw p2 p1
    abox stroke
    grestore
} def }
%
%               #] cbox2 : 
%               #[ triangle :
%
\special{! /triangle{
%
%   Draws a triangle x1,y1,x2,y2,x3,y3
%
    gsw p3 p2 p1
    atriangle stroke
    grestore
} def }
%
%               #] triangle : 
%               #[ btriangle :
%
\special{! /btriangle{
%
%   Draws a blanked out triangle x1,y1,x2,y2,x3,y3
%
    gsw p3 p2 p1
    gsave
    1 setgray atriangle fill
    grestore
    atriangle stroke
    grestore
} def }
%
%               #] btriangle : 
%               #[ gtriangle :
%
\special{! /gtriangle{
%
%   Draws a blanked out gray triangle x1,y1,x2,y2,x3,y3,color
%
    gsw /gcolor ed p3 p2 p1
    1 setgray      atriangle fill
    gcolor setgray atriangle fill
    0 setgray      atriangle stroke
    grestore
} def }
%
%               #] gtriangle : 
%               #[ ctriangle1 :
%
\special{! /ctriangle1{
%
%   Draws a blanked out colored triangle x1,y1,x2,y2,x3,y3
%   Part 1: the background
%
    gsw p3 p2 p1
    atriangle fill
    grestore
} def }
%
%               #] ctriangle1 : 
%               #[ ctriangle2 :
%
\special{! /ctriangle2{
%
%   Draws a blanked out colored triangle x1,y1,x2,y2,x3,y3
%   Part 1: the triangle
%
    gsw p3 p2 p1
    atriangle stroke
    grestore
} def }
%
%               #] ctriangle2 : 
%               #[ btext :
%
\special{! /btext{
%
%       Makes a box that has the text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,text,fontsize,linewidth,scale
%
    gsw /fsize ed /thetext ed translate
    /hsize thetext stringwidth pop def
    /x1 hsize fsize add 2 div neg def
    /y1 fsize 2 mul 3 div neg def
    /x2 x1 neg def /y2 y1 neg def
    gsave 1 setgray abox fill grestore
    abox stroke
    hsize 2 div neg fsize 3 div neg moveto thetext show
    grestore    
} def }
%
%               #] btext : 
%               #[ b2text :
%
\special{! /b2text{
%
%       Makes a box that has two lines of text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,text1,text2,fontsize,linewidth,scale
%
    gsw /fsize ed /text2 ed /text1 ed translate
    /hsize1 text1 stringwidth pop def
    /hsize2 text2 stringwidth pop def
    hsize1 hsize2 lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse
    /x1 hsize fsize add 2 div neg def
    /y1 fsize neg 7 mul 6 div def
    /x2 x1 neg def /y2 y1 neg def
    gsave 1 setgray abox fill grestore
    abox stroke
    hsize1 2 div neg fsize 6 div moveto text1 show
    hsize2 2 div neg fsize 5 mul 6 div neg moveto text2 show
    grestore    
} def }
%
%               #] b2text : 
%               #[ gtext :
%
\special{! /gtext{
%
%       Makes a gray box that has the text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,gray,text,fontsize,linewidth,scale
%
    gsw /fsize ed /thetext ed /graysc ed translate
    /hsize thetext stringwidth pop def
    /x1 hsize fsize add 2 div neg def
    /y1 fsize 2 mul 3 div neg def
    /x2 x1 neg def /y2 y1 neg def
    graysc setgray abox fill 0 setgray abox stroke
    hsize 2 div neg fsize 3 div neg moveto thetext show
    grestore    
} def }
%
%               #] gtext : 
%               #[ ctext1 :
%
\special{! /ctext1{
%
%       Makes a colored box that has the text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,text,fontsize,linewidth,scale
%       Part 1: the background
%
    gsw /fsize ed /thetext ed translate
    /hsize thetext stringwidth pop def
    /x1 hsize fsize add 2 div neg def
    /y1 fsize 2 mul 3 div neg def
    /x2 x1 neg def /y2 y1 neg def
    abox fill
    grestore    
} def }
%
%               #] ctext1 : 
%               #[ ctext2 :
%
\special{! /ctext2{
%
%       Makes a colored box that has the text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,text,fontsize,linewidth,scale
%       Part 2: the box and the text
%
    gsw /fsize ed /thetext ed translate
    /hsize thetext stringwidth pop def
    /x1 hsize fsize add 2 div neg def
    /y1 fsize 2 mul 3 div neg def
    /x2 x1 neg def /y2 y1 neg def
    abox stroke
    hsize 2 div neg fsize 3 div neg moveto thetext show
    grestore    
} def }
%
%               #] ctext2 : 
%               #[ g2text :
%
\special{! /g2text{
%
%       Makes a gray box that has two lines of text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,gray,text1,text2,fontsize,linewidth,scale
%
    gsw /fsize ed /text2 ed /text1 ed /graysc ed translate
    /hsize1 text1 stringwidth pop def
    /hsize2 text2 stringwidth pop def
    hsize1 hsize2 lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse
    /x1 hsize fsize add 2 div neg def
    /y1 fsize neg 7 mul 6 div def
    /x2 x1 neg def /y2 y1 neg def
    graysc setgray abox fill 0 setgray abox stroke
    hsize1 2 div neg fsize 6 div moveto text1 show
    hsize2 2 div neg fsize 5 mul 6 div neg moveto text2 show
    grestore    
} def }
%
%               #] g2text : 
%               #[ c2text1 :
%
\special{! /c2text1{
%
%       Makes a colored box that has two lines of text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,text1,text2,fontsize,linewidth,scale
%       Part 1: the background
%
    gsw /fsize ed /text2 ed /text1 ed translate
    /hsize1 text1 stringwidth pop def
    /hsize2 text2 stringwidth pop def
    hsize1 hsize2 lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse
    /x1 hsize fsize add 2 div neg def
    /y1 fsize neg 7 mul 6 div def
    /x2 x1 neg def /y2 y1 neg def
    abox fill
    grestore    
} def }
%
%               #] c2text1 : 
%               #[ c2text2 :
%
\special{! /c2text2{
%
%       Makes a colored box that has two lines of text centered in it
%       The center of the box is at x,y and the box is just large enough
%       for the text.
%       x,y,text1,text2,fontsize,linewidth,scale
%       Part 2, box and text
%
    gsw /fsize ed /text2 ed /text1 ed translate
    /hsize1 text1 stringwidth pop def
    /hsize2 text2 stringwidth pop def
    hsize1 hsize2 lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse
    /x1 hsize fsize add 2 div neg def
    /y1 fsize neg 7 mul 6 div def
    /x2 x1 neg def /y2 y1 neg def
    abox stroke
    hsize1 2 div neg fsize 6 div moveto text1 show
    hsize2 2 div neg fsize 5 mul 6 div neg moveto text2 show
    grestore    
} def }
%
%               #] c2text2 : 
%               #[ ptext :
%
\special{! /ptext{
%
%   Puts a text at x,y (focal point)
%   phi is a rotation angle
%   Mode tells how the text should be w.r.t. the focal point.
%   fsize is the fontsize
%   Then the text is given.
%   Finally the scale factor should be there
%
    gs
    /text ed
    /fsize ed
    /mode ed
    3 1 roll
    translate rotate    % We are at the focus and have the proper orientation
    mode 3 lt { 0 fsize neg translate } {
        mode 6 lt { /mode mode 3 sub def 0 fsize 2 div neg translate }
        { /mode mode 6 sub def } ifelse } ifelse
    /fsize text stringwidth pop def
    mode 1 eq { fsize 2 div neg 0 translate } {
        mode 2 eq { fsize neg 0 translate } if } ifelse
    0 0 moveto
    text show
    grestore
} def }
%
%               #] ptext : 
%               #[ goval :
%
\special{! /goval{
%
%   Draws a colored oval that overwrites whatever was there.
%   x_center y_center height width rotation color linewidth scale
%
    gsw /gcolor ed /x1 ed /x2 ed /radius ed
%
    translate                               % x and y are still on stack
    x1 rotate
    x2 radius div 1.0 scale
    1 setgray      newpath 0 0 radius 0 360 arc fill
    gcolor setgray newpath 0 0 radius 0 360 arc fill
    0 setgray      newpath 0 0 radius 0 360 arc stroke
    grestore
} def }
%
%               #] goval : 
%               #[ coval1 :
%
\special{! /coval1{
%
%   Draws a oval that overwrites whatever was there.
%   x_center y_center height width rotation linewidth scale
%
    gsw /x1 ed /x2 ed /radius ed
%
    translate                               % x and y are still on stack
    x1 rotate
    x2 radius div 1.0 scale
    newpath 0 0 radius 0 360 arc fill
    grestore
} def }
%
%               #] coval1 : 
%               #[ coval2 :
%
\special{! /coval2{
%
%   Draws a oval that overwrites whatever was there.
%   x_center y_center height width rotation linewidth scale
%
    gsw /x1 ed /x2 ed /radius ed
%
    translate                               % x and y are still on stack
    x1 rotate
    x2 radius div 1.0 scale
    newpath 0 0 radius 0 360 arc stroke
    grestore
} def }
%
%               #] coval2 : 
%               #[ oval :
%
\special{! /oval{
%
%   Draws an oval that does not overwrite whatever was there.
%   x_center y_center height width rotation linewidth scale
%
    gsw /x1 ed /x2 ed /radius ed
%
    translate                               % x and y are still on stack
    x1 rotate
    x2 radius div 1.0 scale
%
    newpath 0 0 radius 0 360 arc stroke
    grestore
} def }
%
%               #] oval : 
%               #[ makecurve :
%
\special{! /docurve{
    x1 2 mul x2 add 3 div
        y1 y0 sub x1 x0 sub div x2 x0 sub mul
        y2 y0 sub x2 x0 sub div x1 x0 sub mul add
        y1 add y0 2 mul add 3 div
    x1 x2 2 mul add 3 div
        y2 y3 sub x2 x3 sub div x1 x3 sub mul
        y1 y3 sub x1 x3 sub div x2 x3 sub mul add
        y2 add y3 2 mul add 3 div
    x2 y2 curveto
} def }
%
\special{! /makecurve{
%
%   Incoming stack:
%   [array of x,y pairs] width scale
%
    gsw /points ed
    /ss points length 2 idiv 2 mul def
    newpath
    ss 4 gt {
        /x1 points 0 get def
        /y1 points 1 get def
        /x2 points 2 get def
        /y2 points 3 get def
        /x3 points 4 get def
        /y3 points 5 get def
        /x0 x1 2 mul x2 sub def
        /y0 y3 y2 sub x3 x2 sub div y2 y1 sub x2 x1 sub div sub 2 mul
            x2 x1 sub dup mul x3 x1 sub div mul
            y1 2 mul add y2 sub def
        x1 y1 moveto
        docurve
        0 2 ss 8 sub { /ii ed
            /x0 points ii       get def
            /y0 points ii 1 add get def
            /x1 points ii 2 add get def
            /y1 points ii 3 add get def
            /x2 points ii 4 add get def
            /y2 points ii 5 add get def
            /x3 points ii 6 add get def
            /y3 points ii 7 add get def
            docurve
        } for
        /x0 points ss 6 sub get def
        /y0 points ss 5 sub get def
        /x1 points ss 4 sub get def
        /y1 points ss 3 sub get def
        /x2 points ss 2 sub get def
        /y2 points ss 1 sub get def
        /x3 x2 2 mul x1 sub def
        /y3 y2 y1 sub x2 x1 sub div y1 y0 sub x1 x0 sub div sub 2 mul
            x2 x1 sub dup mul x2 x0 sub div mul
            y2 2 mul add y1 sub def
        docurve
    } {
        ss 4 eq {
            points 0 get points 1 get moveto
            points 2 get points 3 get lineto
        } if
    } ifelse
    stroke
    grestore
} def }
%
%               #] makecurve : 
%               #[ makedashcurve :
%
\special{! /makedashcurve{
%
%   Incoming stack:
%   [array of x,y pairs] dashsize width scale
%
    gsw /dsize ed /points ed
    /ss points length 2 idiv 2 mul def
    newpath
    ss 4 gt {
        /x1 points 0 get def
        /y1 points 1 get def
        /x2 points 2 get def
        /y2 points 3 get def
        /x3 points 4 get def
        /y3 points 5 get def
        /x0 x1 2 mul x2 sub def
        /y0 y3 y2 sub x3 x2 sub div y2 y1 sub x2 x1 sub div sub 2 mul
            x2 x1 sub dup mul x3 x1 sub div mul
            y1 2 mul add y2 sub def
        x1 y1 moveto
        docurve
        0 2 ss 8 sub { /ii ed
            /x0 points ii       get def
            /y0 points ii 1 add get def
            /x1 points ii 2 add get def
            /y1 points ii 3 add get def
            /x2 points ii 4 add get def
            /y2 points ii 5 add get def
            /x3 points ii 6 add get def
            /y3 points ii 7 add get def
            docurve
        } for
        /x0 points ss 6 sub get def
        /y0 points ss 5 sub get def
        /x1 points ss 4 sub get def
        /y1 points ss 3 sub get def
        /x2 points ss 2 sub get def
        /y2 points ss 1 sub get def
        /x3 x2 2 mul x1 sub def
        /y3 y2 y1 sub x2 x1 sub div y1 y0 sub x1 x0 sub div sub 2 mul
            x2 x1 sub dup mul x2 x0 sub div mul
            y2 2 mul add y1 sub def
        docurve
    } {
        ss 4 eq {
            points 0 get points 1 get moveto
            points 2 get points 3 get lineto
        } if
    } ifelse
    centerdash
    stroke
    grestore
} def }
%
\special{! /pathlength{
    flattenpath
    /dist 0 def
    { /yfirst ed /xfirst ed /ymoveto yfirst def /xmoveto xfirst def }
    { /ynext ed /xnext ed /dist dist ynext yfirst sub dup mul
        xnext xfirst sub dup mul add sqrt add def
        /yfirst ynext def /xfirst xnext def }
    {}
    {/ynext ymoveto def /xnext xmoveto def
        /dist ynext yfirst sub dup mul
              xnext xfirst sub dup mul add sqrt add def
        /yfirst ynext def /xfirst xnext def }
    pathforall
    dist
} def }
%
\special{! /centerdash{
    /pathlen pathlength def
    /jj pathlen dsize div 2.0 div cvi def
    /ddsize pathlen jj 2.0 mul div def
    [ddsize] ddsize 2 div setdash
} def }
%
%               #] makedashcurve : 
%               #[ logaxis :
%
\special{! /logaxis{
%
%   Draws an axis from x1,y1 to x2,y2 with nl log divisions
%   size of the hashes hs, offset F
%   and width W. The stack looks like
%   x1,y1,x2,y2,nl,hs,F,W,scale
%   After the rotation the hash marks are on top if nl is positive and
%   on the bottom if nl is negative
%
    gsw /offset ed /hashsize ed /nlogs ed
    normalizeline /rr ed
    offset 0 ne { /offset offset ln 10 ln div def } if
    /offset offset dup cvi sub def
    newpath
        0 0 moveto
        rr 0 lineto
    /lsize rr nlogs div def
    0 1 nlogs { /x2 ed
        x2 offset ge {
            /y2 x2 offset sub lsize mul def
            y2 rr le {
                y2 0 moveto
                y2 hashsize 1.2 mul lineto
            } if
        } if
    } for
    stroke
    width 0.6 mul setlinewidth
    newpath
    0 1 nlogs { /x2 ed
        2 1 9 {
            ln 10 ln div x2 add
            /xx2 ed
            xx2 offset ge {
                /y2 xx2 offset sub lsize mul def
                y2 rr le {
                    y2 0 moveto
                    y2 hashsize 0.8 mul lineto
                } if
            } if
        } for
    } for
    stroke
    grestore
} def }
%
%               #] logaxis : 
%               #[ linaxis :
%
\special{! /linaxis{
%
%   x1,y1,x2,y2,num_decs,per_dec,hashsize,offset,width,scale
%
    gsw /offset ed /hashsize ed /perdec ed /numdec ed 
    normalizeline
    /rr ed
    newpath
        0 0 moveto
        rr 0 lineto
    /x1 rr numdec perdec mul div def
    /y1 rr numdec div def
    /offset offset x1 mul def 
    0 1 numdec { y1 mul offset sub
        dup 0 ge {
            dup rr le {
                dup 0 moveto
                hashsize 1.2 mul lineto
            } if
        } if
    } for
    stroke
    width 0.6 mul setlinewidth
    newpath
    offset cvi 1 numdec perdec mul offset add {
        x1 mul offset sub
        dup 0 ge {
            dup rr le {
                dup 0 moveto
                hashsize 0.8 mul lineto
            } if
        } if 
    } for
    stroke
    grestore
} def }
%
%               #] linaxis : 
%               #[ dashbezier:
%
\special{! /dashbezier{
%
%   Draws a dashed Bezier with control points x1,y1,x2,y2,x3,y3,x4,y4
%
    gsw /dsize ed p4 p3 p2 p1
% The following is a failed attempt (copied from dashline) to make
% sure there is an integer number of dashes.  It fails because it
% assumes the length of the line is the distance between the two end points.
%    /r y4 y1 sub dup mul x4 x1 sub dup mul add sqrt def
%    /dsize r dsize 2 mul div 0.5 sub round dup 0 le { pop 0 } if 2 mul 1 add
%    r exch div def
    dsize 0 ne
       { [dsize dsize] 0 setdash }
    if
    abezier stroke
    grestore
} def }
%
%               #] dashbezier : 
} 
% ========== End of AtBeginDvi
%=========================================================
%=========================================================

\def\axowidth{0.5 }
\def\axoscale{1.0 }
\def\axoxoff{0 }
\def\axoyoff{0 }
\def\axoxo{0 }
\def\axoyo{0 }
\def\firstcall{1}

\def\AXO@NOTIMPLEMENTED#1{\PackageWarning{axodraw4j}{#1}}

% Postscript code for setting default arrow
\def\AXO@DefaultArrow{%
        1
        \axowidth \space
        \ifAXO@double
            \AXO@CurrentSep \space 0.7 mul add
        \fi
        1 add 1.2 mul % Width.  1.2 factor is from axodraw
                      % Additive term was 1 in axodraw
        % Now put in an extra overall scaling
        \AXO@CurrentArrowScale \space mul
        dup 2 mul \AXO@DefaultArrowAspect \space mul % Length
        \AXO@CurrentArrowInset \space
        arrowVTriangle
}

% Version of picture environment with unitlength set to 1pt
%   as assumed by axodraw 
\newenvironment{axopicture}
{  \begingroup
   \setlength{\unitlength}{1pt}%
   \picture
}
{\endpicture\endgroup}


% The next is used temporarily, it gives the result of parsing an
% arrow-using command to give the Postscript code for setting the
% arrow.
%
%  Keys for optional arguments:
%  First the variables used, with some defaults.
\newif\ifAXO@arrow
\AXO@arrowfalse
\newif\ifAXO@clock
\AXO@clockfalse
\newif\ifAXO@dash
\AXO@dashfalse
\newif\ifAXO@double
\AXO@doublefalse
\newif\ifAXO@flip       % Flip arrow orientation, as in JaxoDraw
\AXO@flipfalse

\def\AXO@Sep{2 }        % Double line separation
\def\AXO@DashSize{3 }

%  Then the definitions of the keys
\define@key{axo}{arrowscale}{%
    \def\AXO@CurrentArrowScale{#1}%
}
\define@key{axo}{arrowwidth}{%
    \def\AXO@CurrentArrowWidth{#1}%
}
\define@key{axo}{arrowlength}{%
    \def\AXO@CurrentArrowLength{#1}%
}
% Make arrowheight a synonym for arrowlength
\let\KV@axo@arrowheight=\KV@axo@arrowlength
%
\define@key{axo}{arrowpos}{%
  \def\AXO@CurrentArrowPos{#1 }
}
%
\define@key{axo}{arrowinset}{%
  \def\AXO@CurrentArrowInset{#1 }
}
% Make inset a synonym for arrowinset
\let\KV@axo@inset=\KV@axo@arrowinset
%
\define@key{axo}{arrow}[true]{%
  \AXO@boolkey{#1}{arrow}%
}
\define@key{axo}{clock}[true]{%
  \AXO@boolkey{#1}{clock}%
}
\define@key{axo}{clockwise}[true]{%
  \AXO@boolkey{#1}{clock}%
}
\define@key{axo}{double}[true]{%
  \AXO@boolkey{#1}{double}%
}
\define@key{axo}{dash}[true]{%
  \AXO@boolkey{#1}{dash}%
}
\define@key{axo}{flip}[true]{%
  \AXO@boolkey{#1}{flip}%
}
\define@key{axo}{linesep}{%
  \def\AXO@CurrentSep{#1 }
}
\define@key{axo}{sep}{%
  \def\AXO@CurrentSep{#1 }
}
\define@key{axo}{dashsize}{%
  \def\AXO@CurrentDashSize{#1 }
}
\define@key{axo}{dsize}{%
  \def\AXO@CurrentDashSize{#1 }
}

%
%  Parsing of optional arguments, etc
%
\def\AXO@Parse#1#2{%
    % Usage: \AXO@Parse#1#2 or \AXO@Parse#1#2[#3]
    % #1 is a command for setting an object, that takes no optional argument
    % #2 and the optional #3 are keyword settings.
    % There then follow the compulsory arguments for the command in #1.
    %
    % E.g., \AXO@Parse{\AXO@Line}{double}(x1,y1)(x2,y2)
    %       \AXO@Parse{\AXO@Line}{double}[arrow](x1,y1)(x2,y2)
    %
    % I will 
    %   (a) Set standard initial settings (arrows, etc)
    %   (b) Parse the keyword settings in #2 and #3, e.g., scale = 3,
    %   (c) Call #1 to make the object
    \AXO@arrowfalse
    \AXO@clockfalse
    \AXO@dashfalse
    \AXO@doublefalse
    \AXO@flipfalse
    \def\AXO@CurrentArrow{
          \AXO@CurrentArrowStroke  \space
          \AXO@CurrentArrowWidth  \space
          \AXO@CurrentArrowLength \space
          \AXO@CurrentArrowInset \space
          arrowVTriangle 
    }%
    \let\AXO@CurrentArrowPos\AXO@ArrowPos
    \let\AXO@CurrentArrowWidth\relax
    \let\AXO@CurrentArrowLength\relax
    \let\AXO@CurrentArrowInset\AXO@ArrowInset
    \let\AXO@CurrentArrowScale\AXO@DefaultArrowScale
    \let\AXO@CurrentArrowStroke\AXO@DefaultArrowStroke
    \let\AXO@CurrentDashSize\AXO@DashSize
    \let\AXO@CurrentSep=\AXO@Sep
    \@ifnextchar[{\AXO@Options{#1}{#2}}%
                 {\AXO@Options{#1}{#2}[]}%
}
%  
\def\AXO@Options#1#2[#3]{%
    % #1 is command to execute, #2 and #3 are options.
    \setkeys{axo}{#2}%
    \setkeys{axo}{#3}%
    \ifx\AXO@CurrentArrowLength\relax
        \ifx\AXO@CurrentArrowWidth\relax
            % AL AW to default
            \let\AXO@CurrentArrow=\AXO@DefaultArrow
        \else
            % AL by default aspect ratio
            \def\AXO@CurrentArrowLength{ 
                \AXO@CurrentArrowWidth \space 2 mul 
                \AXO@DefaultArrowAspect\space mul 
            }%
        \fi
    \else
        \ifx\AXO@CurrentArrowWidth\relax
            % AW by default aspect ratio
            \def\AXO@CurrentArrowWidth{ 
                \AXO@CurrentArrowLength \space 2 div 
                \AXO@DefaultArrowAspect\space div 
            }%
        \fi
    \fi
    \ifAXO@arrow 
        \def\AXO@ArrowArg{
           { \AXO@CurrentArrow \space } \AXO@CurrentArrowPos \space 
        }%
    \else
        \def\AXO@ArrowArg{ { } 0 }%
    \fi
    #1%
}
%
% Now ensure there is a setting for the current arrow
\AXO@Parse{}{}

\def\AXO@PrependOption#1#2{%
    % Run command #1, which has an optional argument, with #2 prepended
    % to the command's optional arguments.  If there are no optional
    % arguments, just run the command with #2 as the optional arguments
    \@ifnextchar[{\AXO@TwoOption{#1}{#2}}%
                 {#1[#2]}%
}
\def\AXO@TwoOption#1#2[#3]{%
   #1[#2,#3]%
}


% Copied from graphicx.sty, for use with boolean keys
% Modified to do lower casing here
\def\AXO@boolkey#1#2{%
  % Wanted to do
  %  \csname AXO@#2\ifx\relax#1\relax true\else\lowercase{#1}\fi\endcsname
  % but there was an error message about a missing \endcsname
  \lowercase{\AXO@boolkeyA{#1}}{#2}%
}
\def\AXO@boolkeyA#1#2{%
  \csname AXO@#2\ifx\relax#1\relax true\else#1\fi\endcsname
}

%=========================================================
%=========================================================


%
%       Now the user callable routines, and their immediate helpers
%
% Commands for setting parameters applicable to subsequent graphical objects:
%
\def\SetLineSep#1{\def\AXO@Sep{#1 }}
\let\SetSep=\SetLineSep
\def\SetWidth#1{\def\axowidth{#1 }}
\def\SetScale#1{\def\axoscale{#1 }}
\def\SetOffset(#1,#2){\def\axoxoff{#1 } \def\axoyoff{#2 }}
\def\SetScaledOffset(#1,#2){\def\axoxo{#1 } \def\axoyo{#2 }}
%
% Commands for making graphical objects:
\def\Arc{%
% \Arc[opt](x,y)(r,theta1,theta2)
% draws an arc centered at (x,y) of radius r, starting at theta1,
% and ending at theta2.  By default: no arrow, undashed, single,
% anticlockwise. 
% Supported options: all arrow settings, all double line settings,
% all dash line settings, clock
%
   \AXO@Parse{\AXO@Arc}{}%
}
%
\def\AXO@Arc(#1,#2)(#3,#4,#5){%
%
%   Draws arc centered at (#1,#2), radius #3, starting and ending
%   angles #4, #5.
%   Double, dashing, arrow, clockwise according to current settings
%
  \put(\axoxoff,\axoyoff){%
     \special{"\axocolor 
     \AXO@ArrowArg \space
     \ifAXO@flip true \else false \fi
     \ifAXO@double \AXO@CurrentSep \space \else 0 \fi
     \ifAXO@dash \AXO@CurrentDashSize \space \else 0 \fi
     \ifAXO@clock true \else false \fi
     #3 #4 #5
     #1 \axoxo add #2 \axoyo add 
     \axowidth \axoscale 
     arc2
  }}%
}
%
%
\def\Gluon{%
%
%   Draws a gluon from (x1,y1) to (x2,y2) with amplitude and number of windings
%
   \AXO@Parse{\AXO@Gluon}{}%
}
%
\def\AXO@Gluon(#1,#2)(#3,#4)#5#6{%
%
%   Draws a gluon from (x1,y1) to (x2,y2) with amplitude #5 and number
%   of windings #6.
%   Assumes options have been set
%
\ifAXO@arrow\AXO@NOTIMPLEMENTED{arrow not implemented for gluon}\fi
\ifAXO@dash\AXO@NOTIMPLEMENTED{dashing not implemented for gluon}\fi
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
  \axoxo add #4 \axoyo add #5 #6 
  \ifAXO@double \AXO@CurrentSep \space \else 0 \fi
  \axowidth \axoscale doublegluon 
}}%
}
%
\def\Photon{%
%   \Photon[opt](x1,y1)(x2,y2){amplitude}{numwind}
%   Draws a photon from (x1,y1) to (x2,y2) with given amplitude and
%   number of windings 
%   Supported options: double, sep, linesep
%
  \AXO@Parse{\AXO@Photon}{}%
}
%
\def\AXO@Photon(#1,#2)(#3,#4)#5#6{%
%
%   Draws a photon from (x1,y1) to (x2,y2) with amplitude #5 and number
%   of windings #6.
%   Assumes options have been set
%
\ifAXO@arrow\AXO@NOTIMPLEMENTED{arrow not implemented for photon}\fi
\ifAXO@dash\AXO@NOTIMPLEMENTED{dashing not implemented for photon}\fi
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
  \axoxo add #4 \axoyo add #5 #6 
  \ifAXO@double \AXO@CurrentSep \space \else 0 \fi
  \axowidth \axoscale doublephoton 
}}%
}
%
\def\ZigZag(#1,#2)(#3,#4)#5#6{
%
%   Draws a zigzag from (x1,y1) to (x2,y2) with amplitude and number of zigzags
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 #6 \axowidth \axoscale zigzag 
}}
}
%
\def\PhotonArc{%
%   \PhotonArc(x,y)(r,theta1,theta2){amplitude}{numwind}
%   draws a photon on an arc centered at (x,y) of radius r, starting
%   at theta1, and ending at theta2, with given amplitude and
%   number of windings 
%
  \AXO@Parse{\AXO@PhotonArc}{}%
}
%
\def\AXO@PhotonArc(#1,#2)(#3,#4,#5)#6#7{%
%
%   Draws a photon on an arc segment. The center of the curve is at (1,2)
%   The radius, start angle and target angle are (#3,#4,#5), #6 is the
%   amplitude of the gluon, and #7 is the number of wiggles.
%   Assumes options have been set
%
\ifAXO@arrow\AXO@NOTIMPLEMENTED{arrow not implemented for photon arc}\fi
\ifAXO@dash\AXO@NOTIMPLEMENTED{dashing not implemented for photon arc}\fi
\put(\axoxoff,\axoyoff){\special{"\axocolor
    #6 #7 
    \ifAXO@double \AXO@CurrentSep \space \else 0 \fi
    \ifAXO@clock true \else false \fi
    #3 #4 #5
    #1 \axoxo add #2 \axoyo add 
    \axowidth \axoscale 
    doublephotonarc
}}%
}
%
\def\GluonArc{%
%   \GluonArc(x,y)(r,theta1,theta2){amplitude}{numwind}
%   draws a gluon on an arc centered at (x,y) of radius r, starting
%   at theta1, and ending at theta2, with given amplitude and
%   number of windings 
%
  \AXO@Parse{\AXO@GluonArc}{}%
}
%
\let\GlueArc=\GluonArc  % For backward compatibility
%
\def\AXO@GluonArc(#1,#2)(#3,#4,#5)#6#7{%
%
%   Draws a gluon on an arc segment. The center of the curve is at (1,2)
%   The radius, start angle and target angle are (#3,#4,#5), #6 is the
%   amplitude of the gluon, and #7 is the number of windings.
%   Assumes options have been set
%
\ifAXO@arrow\AXO@NOTIMPLEMENTED{arrow not implemented for gluon arc}\fi
\ifAXO@dash\AXO@NOTIMPLEMENTED{dashing not implemented for gluon arc}\fi
\put(\axoxoff,\axoyoff){\special{"\axocolor 
    #6 #7 
    \ifAXO@double \AXO@CurrentSep \space \else 0 \fi
    \ifAXO@clock true \else false \fi
    #3 #4 #5
    #1 \axoxo add #2 \axoyo add 
    \axowidth \axoscale 
    doublegluearc
}}%
}
%
\def\ArrowArc{%
   \AXO@PrependOption{\Arc}{arrow}%
}
%
\def\LongArrowArc{%
   \AXO@PrependOption{\Arc}{arrow,arrowpos=1}%
}
%
\def\DashArrowArc{%
%   (x,y)(radius,start,end){dashsize}
%   Draws a dashed arc segment with an arrow in it. The center of the curve
%   is at (x,y), with given radius, start angle, and end angle
%   The arc segment runs anticlockwise
   \@ifnextchar[{\AXO@DashArrowArc}{\AXO@DashArrowArc[]}%
}
\def\AXO@DashArrowArc[#1](#2,#3)(#4,#5,#6)#7{
  \Arc[arrow,dash,dashsize=#7,#1](#2,#3)(#4,#5,#6)%
}
%
\def\ArrowArcn{%
   \AXO@PrependOption{\Arc}{arrow,clock}%
}
%
\def\LongArrowArcn{%
   % \ArrowArcn, but with arrow at end by default
   \AXO@PrependOption{\Arc}{arrow, clock, arrowpos=1}%
}
%
\def\DashArrowArcn{%
%   (x,y)(radius,start,end){dashsize}
%   Draws a dashed arc segment with an arrow in it. The center of the curve
%   is at (x,y), with given radius, start angle, and end angle
%   The arc segment runs anticlockwise
   \@ifnextchar[{\AXO@DashArrowArcn}{\AXO@DashArrowArcn[]}%
}
\def\AXO@DashArrowArcn[#1](#2,#3)(#4,#5,#6)#7{
  \Arc[clock,arrow,dash,dashsize=#7,#1](#2,#3)(#4,#5,#6)%
}
%
\def\ArrowDoubleLine{%
%
%   \ArrowDoubleLine[opt](x1,y1)(x2,y2){sep}
%   Draws a double line, with arrow by default, from (x1,y1) to (x2,y2),
%      with separation sep
%
   \@ifnextchar[{\AXO@ADoL}{\AXO@ADoL[]}%
}
\def\AXO@ADoL[#1](#2,#3)(#4,#5)#6{%
   \Line[arrow,double,sep=#6,#1](#2,#3)(#4,#5)%
}
%
\def\DashArrowDoubleLine{%
%   \DashArrowDoubleLine[opt](x1,y1)(x2,y2){sep}{dashsize}
%   Draws a double line from (x1,y1) to (x2,y2) with separation sep,
%   and with a dash pattern of which the
%   alternating black and white pieces are approximately sep points long
%   Arrow on.
   \@ifnextchar[{\AXO@ADaDoL}{\AXO@ADaDoL[]}%
}
\def\AXO@ADaDoL[#1](#2,#3)(#4,#5)#6#7{%
    \Line[arrow,dash,dashsize=#7,double,sep=#6,#1](#2,#3)(#4,#5)%
}
%
\def\ArrowLine{%
% \ArrowLine[opt](x1,y1)(x2,y2)
% draws a line from (x1,y1) to (x2,y2).  Arrow by default.
%
   \AXO@PrependOption{\Line}{arrow}%
}
%
\def\LongArrow{%
   \AXO@PrependOption{\Line}{arrow, arrowpos=1}%
}
%
\def\DashArrowLine{
%   \DashArrowLine[opt](x1,y1)(x2,y2){sep}
%   Draws a line from (x1,y1) to (x2,y2) with a dash pattern of which the
%   alternating black and white pieces are approximately sep points
%   long.   Arrow by default.
%
   \@ifnextchar[{\AXO@ADaL}{\AXO@ADaL[]}%
}
\def\AXO@ADaL[#1](#2,#3)(#4,#5)#6{%
    \Line[arrow,dash,dashsize=#6,#1](#2,#3)(#4,#5)%
}
%
\def\Line{
% \Line[opt](x1,y1)(x2,y2)
% draws a line from (x1,y1) to (x2,y2).  NO arrow by default.
% Supported options: all arrow settings, all double line settings,
% all dash line settings.
%
   \AXO@Parse{\AXO@Line}{}%
}
%
\def\AXO@Line(#1,#2)(#3,#4){
%
%   Draws a line from (x1,y1) to (x2,y2)
%   Double, dashing, arrow according to current settings
%
  \put(\axoxoff,\axoyoff){%
     \special{"\axocolor \space
       \AXO@ArrowArg \space
       \ifAXO@flip true \else false \fi
       \ifAXO@double \AXO@CurrentSep \space \else 0 \fi
       \ifAXO@dash \AXO@CurrentDashSize \space \else 0 \fi
       #1 \axoxo add #2 \axoyo add
       #3 \axoxo add #4 \axoyo add 
       \axowidth \space \axoscale \space
       dasharrowdoubleline
  }}%
}
%
%
\def\DashLine{
%   \DashLine[opt](x1,y1)(x2,y2){sep}
%   Draws a line from (x1,y1) to (x2,y2) with a dash pattern of which the
%   alternating black and white pieces are approximately sep points long
%
   \@ifnextchar[{\AXO@DaL}{\AXO@DaL[]}%
}
\def\AXO@DaL[#1](#2,#3)(#4,#5)#6{%
    \Line[dash,dashsize=#6,#1](#2,#3)(#4,#5)%
}
%
\def\DoubleLine{
%
%   \DoubleLine[opt](x1,y1)(x2,y2){sep}
%   Draws a double line, with NO arrow by default, from (x1,y1) to (x2,y2),
%      with separation sep
%
   \@ifnextchar[{\AXO@DoL}{\AXO@DoL[]}%
}
\def\AXO@DoL[#1](#2,#3)(#4,#5)#6{%
   \Line[arrow=false,double,sep=#6,#1](#2,#3)(#4,#5)%
}
%
\def\DashDoubleLine{
%   \DashDoubleLine[opt](x1,y1)(x2,y2){sep}{dashsize}
%   Draws a double line from (x1,y1) to (x2,y2) with separation sep,
%   and with a dash pattern of which the
%   alternating black and white pieces are approximately sep points long
%   Arrow on.
   \@ifnextchar[{\AXO@DaDoL}{\AXO@DaDoL[]}%
}
\def\AXO@DaDoL[#1](#2,#3)(#4,#5)#6#7{%
    \Line[arrow=off,dash,dashsize=#7,double,sep=#6,#1](#2,#3)(#4,#5)%
}
%
\def\CArc(#1,#2)(#3,#4,#5){%
%
%   Draws an arc segment. The center of the curve
%   is at (#1,#2).
%   The radius, start angle and target angle are (#3,#4,#5).
%   The arc segment runs anticlockwise
%
   \Arc(#1,#2)(#3,#4,#5)%
}
%
\def\DashCArc(#1,#2)(#3,#4,#5)#6{
%
%   Draws a dashed arc segment. The center of the curve
%   is at (1,2).
%   The radius, start angle and target angle are (#3,#4,#5).
%   The arc segment runs anticlockwise
%   #6 is the dashsize. this is rounded to make things come
%   out right.
%
    \Arc[dash,dsize=#6](#1,#2)(#3,#4,#5)%
}
%
\def\Vertex(#1,#2)#3{
%
%   Draws a fat dot at (1,2). The radius of the dot is given by 3.
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoscale vertex 
}}
}
%
\def\Text(#1,#2)[#3]#4{
%
%   Draws text at (1,2). Argument 3 is l,r or c indicating whether
%   the text is left adjusted, right adjusted or centered.
%   4 is of course the text.
%
\dimen0=\axoxoff \unitlength
\dimen1=\axoyoff \unitlength
\advance\dimen0 by #1 \unitlength
\advance\dimen1 by #2 \unitlength
\@killglue\raise\dimen1\hbox to\z@{\kern\dimen0 \makebox(0,0)[#3]{#4}\hss}
\ignorespaces
}
%
\def\BCirc(#1,#2)#3{
%
%   Draws a circle at (1,2) and radius 3 that is blanked out.
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axowidth \axoscale bcirc 
}}
}
%
\def\GCirc(#1,#2)#3#4{
%
%   Draws a circle at (1,2) and radius 3 that is blanked out.
%   Then it fills the circle with a gray scale 4 (0 = black, 1 is white)
%
\put(\axoxoff,\axoyoff){\special{"#1 \axoxo add #2 \axoyo add #3
 #4 \axowidth \axoscale gcirc 
}}
}
%
\def\CCirc(#1,#2)#3#4#5{
%
%   Draws a circle at (1,2) and radius 3 that is blanked out.
%   #4 is the color of the circle, #5 the color of the contents
%
\put(\axoxoff,\axoyoff){\special{"#5 #1 \axoxo add #2 \axoyo add #3
 \axowidth \axoscale ccirc1 
}}
\put(\axoxoff,\axoyoff){\special{"#4 #1 \axoxo add #2 \axoyo add #3
 \axowidth \axoscale ccirc2 
}}
}
%
\def\EBox(#1,#2)(#3,#4){
%
%   Draws a box with the left bottom at (x1,y1) and the right top
%   at (x2,y2).
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add \axowidth \axoscale box 
}}
}
%
\def\BBox(#1,#2)(#3,#4){
%
%   Draws a box with the left bottom at (x1,y1) and the right top
%   at (x2,y2). The box is blanked out.
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add \axowidth \axoscale bbox 
}}
}
%
\def\GBox(#1,#2)(#3,#4)#5{
%
%   Draws a box with the left bottom at (x1,y1) and the right top
%   at (x2,y2). The box is blanked out and then filled with gray 5
%   (0 is black, 1 is white)
%
\put(\axoxoff,\axoyoff){\special{"#1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axowidth \axoscale gbox 
}}
}
%
\def\CBox(#1,#2)(#3,#4)#5#6{
%
%   Draws a box with the left bottom at (x1,y1) and the right top
%   at (x2,y2). The color of the box is #5, the background is #6
%
\put(\axoxoff,\axoyoff){\special{"#6 #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add \axowidth \axoscale cbox1 
}}
\put(\axoxoff,\axoyoff){\special{"#5 #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add \axowidth \axoscale cbox2 
}}
}
%
\def\Boxc(#1,#2)(#3,#4){
%
%   Draws a box with the center at (x1,y1).
%   The width and height are (3,4).
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #3 2 div sub #2 \axoyo add
 #4 2 div sub #1 \axoxo add #3 2 div add #2 \axoyo add #4 2 div add
 \axowidth \axoscale box 
}}
}
%
\def\BBoxc(#1,#2)(#3,#4){
%
%   Draws a box with the center at (x1,y1).
%   The width and height are (3,4). The contents are blanked out
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #3 2 div sub #2 \axoyo add
 #4 2 div sub #1 \axoxo add #3 2 div add #2 \axoyo add #4 2 div add
 \axowidth \axoscale bbox 
}}
}
%
\def\GBoxc(#1,#2)(#3,#4)#5{
%
%   Draws a box with the center at (x1,y1).
%   The width and height are (3,4). The contents are blanked out
%   Then the contents are filled with gray 5 (0 is black, 1 is white)
%
\put(\axoxoff,\axoyoff){\special{"#1 \axoxo add #3 2 div sub #2 \axoyo add
 #4 2 div sub #1 \axoxo add #3 2 div add #2 \axoyo add #4 2 div add
 #5 \axowidth \axoscale gbox 
}}
}
%
\def\CBoxc(#1,#2)(#3,#4)#5#6{
%
%   Draws a box with the center at (x1,y1).
%   The width and height are (3,4). The contents are blanked out
%   The color of the box is #5, the background is #6
%
\put(\axoxoff,\axoyoff){\special{"#6 #1 \axoxo add #3 2 div sub #2 \axoyo add
 #4 2 div sub #1 \axoxo add #3 2 div add #2 \axoyo add #4 2 div add
 \axowidth \axoscale cbox1 
}}
\put(\axoxoff,\axoyoff){\special{"#5 #1 \axoxo add #3 2 div sub #2 \axoyo add
 #4 2 div sub #1 \axoxo add #3 2 div add #2 \axoyo add #4 2 div add
 \axowidth \axoscale cbox2 
}}
}
%
\def\ETri(#1,#2)(#3,#4)(#5,#6){
%
%   Draws a triangle with the corners (x1,y1), (x2,y2), (x3,y3)
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axoxo add #6 \axoyo add
 \axowidth \axoscale triangle 
}}
}
%
\def\BTri(#1,#2)(#3,#4)(#5,#6){
%
%   Draws a triangle with the corners (x1,y1), (x2,y2), (x3,y3)
%   The triangle is blanked out.
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axoxo add #6 \axoyo add
 \axowidth \axoscale btriangle 
}}
}
%
\def\GTri(#1,#2)(#3,#4)(#5,#6)#7{
%
%   Draws a triangle with the corners (x1,y1), (x2,y2), (x3,y3)
%   The triangle is blanked out and then filled with gray 7
%   (0 is black, 1 is white)
%
\put(\axoxoff,\axoyoff){\special{"#1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axoxo add #6 \axoyo add #7
 \axowidth \axoscale gtriangle 
}}
}
%
\def\CTri(#1,#2)(#3,#4)(#5,#6)#7#8{
%
%   Draws a triangle with the corners (x1,y1), (x2,y2), (x3,y3)
%   The color of the box is #7, the background is #8
%
\put(\axoxoff,\axoyoff){\special{"#8 #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axoxo add #6 \axoyo add
 \axowidth \axoscale ctriangle1 
}}
\put(\axoxoff,\axoyoff){\special{"#7 #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axoxo add #6 \axoyo add
 \axowidth \axoscale ctriangle2 
}}
}
%
\def\pfont{Times-Roman }
\def\fsize{10 }
%
\def\SetPFont#1#2{\def\pfont{#1 } \def\fsize{#2 }}
%
%   Now some definitions to sort out the lt etc type of options in PText
%
\def\fmode{4 }
\def\@l@{l} \def\@r@{r} \def\@t@{t} \def\@b@{b}
\def\mymodetest#1{\ifx#1\end \let\next=\relax \else {
\if#1\@r@\global\def\fmodeh{1 }\fi
\if#1\@l@\global\def\fmodeh{-1 }\fi
\if#1\@b@\global\def\fmodev{3 }\fi
\if#1\@t@\global\def\fmodev{-3 }\fi
} \let\next=\mymodetest\fi \next}
%
\def\PText(#1,#2)(#3)[#4]#5{
%
%   Draws a postscript text in a postscript font.
%   Focal point is (1,2), rotation angle is 3, 4 is the mode (as in text)
%   and 5 is the text.
%
\def\fmodev{0 }
\def\fmodeh{0 }
\mymodetest#4\end
\put(\axoxoff,\axoyoff){\makebox(0,0)[]{\special{"/\pfont findfont \fsize
 scalefont setfont \axocolor #1 \axoxo add #2 \axoyo add #3
\fmode \fmodev add \fmodeh add \fsize (#5) \axoscale ptext }}}
}
%
\def\GOval(#1,#2)(#3,#4)(#5)#6{
%
%   Draws a colored oval that overwrites whatever was there.
%   Oval(x_center,y_center)(height,width)(rotation)(color)
%
\put(\axoxoff,\axoyoff){\special{"#1 \axoxo add #2 \axoyo add #3 #4 #5 #6
\axowidth \axoscale goval 
}}
}
%
\def\COval(#1,#2)(#3,#4)(#5)#6#7{
%
%   Draws a colored oval that overwrites whatever was there.
%   Oval(x_center,y_center)(height,width)(rotation){color1}{color2}
%
\put(\axoxoff,\axoyoff){\special{"#7 #1 \axoxo add #2 \axoyo add #3 #4 #5
\axowidth \axoscale coval1 
}}
\put(\axoxoff,\axoyoff){\special{"#6 #1 \axoxo add #2 \axoyo add #3 #4 #5
\axowidth \axoscale coval2 
}}
}
%
\def\Oval(#1,#2)(#3,#4)(#5){
%
%   Draws an oval that does not overwrite whatever was there.
%   Oval(x_center,y_center)(height,width)(rotation)
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3 #4 #5
\axowidth \axoscale oval 
}}
}
%
\let\eind=]
\def\DashCurve#1#2{\put(\axoxoff,\axoyoff){\special{"\axocolor  [ \kromme#1] #2
\axowidth \axoscale makedashcurve 
}}}
\def\Curve#1{\put(\axoxoff,\axoyoff){\special{"\axocolor [ \kromme#1] \axowidth
\axoscale makecurve 
}}}
\def\kromme(#1,#2)#3{#1 \axoxo add #2 \axoyo add \ifx #3\eind\else
\expandafter\kromme\fi#3}
%
\def\LogAxis(#1,#2)(#3,#4)(#5,#6,#7,#8){
%
%   Draws a line with logarithmic hash marks along it.
%   LogAxis(x1,y1)(x2,y2)(num_logs,hashsize,offset,width)
%   The line is from (x1,y1) to (x2,y2) and the marks are on the left side
%   when hashsize is positive, and right when it is negative.
%   num_logs is the number of orders of magnitude and offset is the number
%   at which one starts at (x1,y1) (like if offset=2 we start at 2)
%   When offset is 0 we start at 1. Width is the linewidth.
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 #6 #7 #8 \axoscale logaxis 
}}
}
%
\def\LinAxis(#1,#2)(#3,#4)(#5,#6,#7,#8,#9){
%
%   Draws a line with linear hash marks along it.
%   LinAxis(x1,y1)(x2,y2)(num_decs,per_dec,hashsize,offset,width)
%   The line is from (x1,y1) to (x2,y2) and the marks are on the left side
%   when hashsize is positive, and right when it is negative.
%   num_decs is the number of accented marks, per_dec the number of
%   divisions between them and offset is the number
%   at which one starts at (x1,y1) (like if offset=2 we start at the second
%   small mark) Width is the linewidth.
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 #6 #7 #8 #9 \axoscale linaxis 
}}
}
%
%
\def\rText(#1,#2)[#3][#4]#5{
%
%   Draws rotated text at (1,2). Argument 3 is l,r or c indicating whether
%   the text is left adjusted, right adjusted or centered.
%   4 is the rotation angle and 5 is of course the text.
%
\ifnum\firstcall=1\global\def\firstcall{0}\rText(-10000,#2)[#3][]{#5}\fi
\dimen2=\axoxoff \unitlength
\dimen3=\axoyoff \unitlength
\advance\dimen2 by #1 \unitlength
\advance\dimen3 by #2 \unitlength
\@killglue\raise\dimen3\hbox to \z@{\kern\dimen2
\makebox(0,0)[#3]{
\ifx#4l{\setbox3=\hbox{#5}\rotl{3}}\else{
\ifx#4r{\setbox3=\hbox{#5}\rotr{3}}\else{
\ifx#4u{\setbox3=\hbox{#5}\rotu{3}}\else{#5}\fi}\fi}\fi}\hss}
\ignorespaces
}
%
\def\BText(#1,#2)#3{
%
%   Draws a box with the center at (x1,y1) and postscript text in it.
%
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont \axocolor #1 \axoxo add #2 \axoyo add (#3)
 \fsize \axowidth \axoscale btext 
}}
}
%
\def\GText(#1,#2)#3#4{
%
%   Draws a box with the center at (x1,y1) and postscript(#4) text in it.
%   The grayness of the box is given by #3
%
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont #1 \axoxo add #2 \axoyo add #3 (#4)
 \fsize \axowidth \axoscale gtext 
}}
}
%
\def\CText(#1,#2)#3#4#5{
%
%   Draws a box with the center at (x1,y1) and postscript(#5) text in it.
%   The color of box and text is in #3
%   The color of the background is in #4
%
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont #4 #1 \axoxo add #2 \axoyo add (#5)
 \fsize \axowidth \axoscale ctext1 
}}
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont #3 #1 \axoxo add #2 \axoyo add (#5)
 \fsize \axowidth \axoscale ctext2 
}}
}
%
\def\BTwoText(#1,#2)#3#4{
%
%   Draws a box with the center at (x1,y1) and two lines of postscript
%   text in it.
%
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont \axocolor #1 \axoxo add #2 \axoyo add (#3) (#4)
 \fsize \axowidth \axoscale b2text 
}}
}
%
\def\GTwoText(#1,#2)#3#4#5{
%
%   Draws a box with the center at (x1,y1) and two lines of postscript
%   text (#4 and #5) in it.
%   The grayness of the box is given by #3
%
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont #1 \axoxo add #2 \axoyo add #3 (#4) (#5)
 \fsize \axowidth \axoscale g2text 
}}
}
%
\def\CTwoText(#1,#2)#3#4#5#6{
%
%   Draws a box with the center at (x1,y1) and two lines of postscript
%   text (#5 and #6) in it.
%   The color of the box and the text is given by #3
%   The background color is given by #4
%
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont #4 #1 \axoxo add #2 \axoyo add (#5) (#6)
 \fsize \axowidth \axoscale c2text1 
}}
\put(\axoxoff,\axoyoff){\special{"/\pfont findfont \fsize
 scalefont setfont #3 #1 \axoxo add #2 \axoyo add (#5) (#6)
 \fsize \axowidth \axoscale c2text2 
}}
}
\def\Bezier{
%   \Bezier[opt](x1,y1)(x2,y2)(x3,y3)(x4,y4)
%   Draws a Bezier cubic with the control points (x1,y1), (x2,y2), (x3,y3), (x4,y4)
%   Supported options: dash, dashsize and dashsize
   \AXO@Parse{\AXO@Bezier}{}%
}
\def\AXO@Bezier(#1,#2)(#3,#4)(#5,#6)(#7,#8){%
%   Draws a Bezier cubic with the control points (x1,y1), (x2,y2),
%   (x3,y3), (x4,y4)
%   Assumes options have been set
%
\put(\axoxoff,\axoyoff){\special{"\axocolor #1 \axoxo add #2 \axoyo add #3
 \axoxo add #4 \axoyo add #5 \axoxo add #6 \axoyo add #7 \axoxo add #8
 \axoyo add
 \ifAXO@arrow\AXO@NOTIMPLEMENTED{arrow not implemented for Bezier curve}\fi
 \ifAXO@double\AXO@NOTIMPLEMENTED{double line not implemented for Bezier curve}\fi
 \ifAXO@dash 
     \AXO@CurrentDashSize \space
 \else
     0
 \fi
 \axowidth \axoscale 
 dashbezier 
}}%
}
\def\DashBezier(#1,#2)(#3,#4)(#5,#6)(#7,#8)#9{%
%
%   Draws a Bezier cubic with control points (x1,y1), (x2,y2),
%   (x3,y3), (x4,y4) with a dash pattern of which the 
%   alternating black and white pieces are approximately #9 points long
%
   \Bezier[dash,dashsize=#9](#1,#2)(#3,#4)(#5,#6)(#7,#8)%
}
%
